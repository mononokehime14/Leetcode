# 独孤九剑 #
归妹趋无妄 无妄趋同人 同人趋大有


甲转丙 丙转庚 庚转癸 


子丑之交 辰巳之交 午未之交


风雷是一变 山泽是一变 水火是一变 


乾坤相激 震兑相激 离巽相激


三增而成五 五增而成九
## Greedy ##
1. Overlapping circles, 这类题目通常要先转一个弯, 题目求的是minimum remove, 那么能不能做到每一次remove最大化价值?
自然而然顺延到了贪心的思路, 也就是local optimal累积为global optimal.


## 双指针 ##
1. 左右, 快慢, 并行. 左右、并行指针常见数组问题, 快慢指针常见链表问题. 
2. 左右指针比如two sum sorted中来, 往往两个candidate拼凑答案, 就可以左右指针试. panlindrome的检查使用左右指针扫一遍, 搞清楚parentheses的检查则是用stack.
3. 快慢指针经典用于判定链表是否有环 
4. 并行指针往往是检查两个数组是不是有某种共同的pattern, 或者merge sorted array, 要点在于两者order的保持.


## Math ## 
1. 对规定1～N内的数字 寻找missing等 可以用index配对方法
2. 快速幂用某种分而治之的思路 区分奇偶 偶数直接平方 奇数平方再乘以底数
3. 质数 丑数 思路是快速筛选法
4. 通过n&(n-1)可以消除掉n的最后一位1
5. 对于任何数字a a ^ 0 = a, a ^ a = 0


## 二分搜索 ##
1. 有一类题目是通过二分搜索尝试答案是否正确做出来的 比如快速寻找sqrt 注意要知道min max


## DP ##
1. 子序列问题。DP三个经典子序列问题应该是最长增长子序列 最长公共子序列 最长回文子序列问题
* 子序列问题是不同于子数组问题的 子数组要求连续 滑动窗口可能可以解决问题 但是子序列是可以断开挑选的 如果暴力解
* 选择造成的递归树应该至少有2的n次方 所以几乎肯定要用DP了
* 其中 最长增长子序列的状态选择方程是一维的 dp[i]的定义是到i为止最长的增长子序列 转移是取决于前面比i小的数字的dp值
* 当然 有快速的nlogn方法
* 最长公共子序列是两个string 所以dp二维 dp[i][j]的定义是第一个string到i和第二个string到j的最长公共子序列
* 但是最长回文子序列要怎么操作呢 dp[i][j]可以定义成i到j之间的最长回文子序列
* 这样状态转移就是如果i的char和j的char相同 就必然可以加入到回文序列里 因为子序列不要求连续 
* 而如果不相同 i和j就不可能在一个回文序列里了 就可以dp[i+1][j] dp[i][j-1]挑一个最大的 这两个都是前面已经算出来极值的

2. 上题的最长回文子序列问题揭示了一种DP的思路，那就是DP[i][j]代表从i到j的区间内，答案要求的极值。这时候的base case通常就是DP[i][i]，迭代方向是从右下角开始，向上迭代，遍历DP矩阵的右边三角。

在准备国内面试时再次整理了DP问题，follow了这篇知乎帖子：
https://zhuanlan.zhihu.com/p/91582909
DP问题的解决确实按照经验，可以分为三个重要的部分，第一是dp数组怎么定义，DP[i]或者DP[i][j]代表什么，第二是关系式，如何去计算出dp值，也就是所谓状态转移方程，第三是base case是什么。

1. 如何定义DP数组

可以简单的定义DP[i]代表题目要求的那个极值，比如最长递增子序列，DP[i]代表以i结尾的最长递增子序列的长度。简单的1D比如Jump Game，2D比如Unique Paths。

对于两个String，可以考虑DP[i][j]代表长i的String1和长j的string2的答案，比如编辑距离，最长公共子序列。

3. 如何确定base case

在如Unique Path，minimum path sums这类题目中，二维矩阵的base case很可能是要对第一行第一列做处理。